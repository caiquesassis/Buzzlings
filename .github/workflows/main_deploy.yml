name: Build, Test and Deploy Buzzlings #The name of the workflow that appears in the GitHub Actions UI

on:
  push:
    branches:
      - main #Every time you push code to the main branch, the process starts automatically
  workflow_dispatch: #This adds the manual "Run Workflow" button in the GitHub UI

jobs: #Workflows are divided into jobs
  build-and-test: #The ID of our first job
    name: Build & Run Tests 
    runs-on: ubuntu-latest #We are asking GitHub for a fresh Linux virtual machine to run our code

    steps: #The sequence of commands the machine will follow
      - name: Checkout Code
        uses: actions/checkout@v4 #The machine starts empty. This "clones" the repository into the virtual machine so it can see the .sln and .csproj files.

      - name: Setup .NET
        uses: actions/setup-dotnet@v4 #Installs the .NET SDK. We specified 9.0.x to match the project
        with:
          dotnet-version: '9.0.x'

      - name: Restore Dependencies
        run: dotnet restore Buzzlings.sln #Downloads all the NuGet packages (dependencies) for every project in the solution

      - name: Build Solution
        run: dotnet build Buzzlings.sln --no-restore --configuration Release #Compiles the entire solution. --no-restore speeds it up because we just did it. Release mode optimizes the code for production

      - name: Run Unit Tests
        #Runs all tests in the tests/Buzzlings.Tests folder
        #SQLite tests work out of the box on the runner
        run: dotnet test Buzzlings.sln --no-build --configuration Release --verbosity normal #It runs all tests in tests/Buzzlings.Tests/. Because we use SQLite, it creates the DB file in the machine's RAM, runs the tests, and deletes it. If any test fails, the workflow stops here and won't deploy.

      - name: Publish Web App
        #Publishing the Web project (the MVC/Frontend part)
        run: dotnet publish src/Buzzlings/Buzzlings.Web.csproj -c Release -o ./publish_output #This prepares the "Final Package." It gathers only the files needed to run the app (DLLs, Views, wwwroot) and puts them in a folder called ./publish_output

      #We upload the artifact so the next job can use it (best practice for security)
      - name: Upload Build Artifact
        uses: actions/upload-artifact@v4 #This saves the ./publish_output folder in GitHub's "cloud storage." This is safer than passing files directly between jobs
        with:
          name: webapp-dist
          path: ./publish_output

  deploy:
    name: Deploy to Azure
    needs: build-and-test #Only runs if tests pass, this is critical. It tells GitHub: "Do not start the deployment unless the Build and Test job finished successfully."
    runs-on: ubuntu-latest #A second fresh machine is used for the deployment phase
    
    steps:
      - name: Download Build Artifact
        uses: actions/download-artifact@v4 #We download that "Final Package" we saved before
        with:
          name: webapp-dist
          path: ./publish_output

      - name: Login to Azure
        uses: azure/login@v2 #This is where the machine "logs in" to our Azure account
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          client-secret: ${{ secrets.AZURE_CLIENT_SECRET }}

      - name: Deploy to Azure Web App
        uses: azure/webapps-deploy@v3 #The final act. It takes the files from ./publish_output and uploads them to our Azure App Service
        with:
          app-name: 'app-buzzlings-web-brazilsouth-prod-001' #Tells Azure exactly which "slot" or website to overwrite with the new code.
          package: ./publish_output